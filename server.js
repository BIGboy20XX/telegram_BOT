import express from "express";
import fetch from "node-fetch";
import * as cheerio from "cheerio";
import crypto from "crypto";
import { Pool } from "pg";
import Parser from "rss-parser";

const app = express();
app.use(express.json({ limit: "2mb" }));

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

const TELEGRAM_TOKEN = process.env.TELEGRAM_TOKEN;
if (!TELEGRAM_TOKEN) {
  console.error("‚ùå –û—à–∏–±–∫–∞: TELEGRAM_TOKEN –Ω–µ –∑–∞–¥–∞–Ω!");
  process.exit(1);
}
const TELEGRAM_API = `https://api.telegram.org/bot${TELEGRAM_TOKEN}`;
const rssParser = new Parser();

// üîß –ü—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
const PRESET_SELECTORS = {
  "instagram.com": ".x1lliihq",
  "twitter.com": "article",
  "reddit.com": ".Post",
  "tumblr.com": ".post"
};

// üîß RSS-–∑–µ—Ä–∫–∞–ª–∞
const RSS_MIRRORS = {
  "twitter.com": url => {
    const username = url.split("/").filter(Boolean).pop();
    return `https://nitter.net/${username}/rss`;
  },
  "x.com": url => {
    const username = url.split("/").filter(Boolean).pop();
    return `https://nitter.net/${username}/rss`;
  },
  "instagram.com": url => {
    const username = url.split("/").filter(Boolean).pop();
    return `https://rsshub.app/instagram/user/${username}`;
  },
  "reddit.com": url => {
    return url.endsWith("/") ? `${url}.rss` : `${url}/.rss`;
  }
};

// üîß –ü–æ—Å—Ç–æ—è–Ω–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
const MAIN_KEYBOARD = {
  keyboard: [
    [{ text: "‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–∞–π—Ç" }, { text: "üìã –ú–æ–∏ —Å–∞–π—Ç—ã" }],
    [{ text: "‚ùå –£–¥–∞–ª–∏—Ç—å —Å–∞–π—Ç" }, { text: "üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è" }],
    [{ text: "‚ÑπÔ∏è –ü–æ–º–æ—â—å" }]
  ],
  resize_keyboard: true
};

// üîß –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π fetch
async function safeFetch(url) {
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 15000); // 15 —Å–µ–∫
    const res = await fetch(url, { signal: controller.signal });
    clearTimeout(timeout);
    if (!res.ok) throw new Error(`Status ${res.status}`);
    return await res.text();
  } catch (err) {
    throw new Error(`Fetch error: ${err.message}`);
  }
}

// üì© –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
async function sendTelegramMessage(chatId, text, keyboard = null) {
  try {
    const body = {
      chat_id: chatId,
      text,
      parse_mode: "HTML",
      reply_markup: keyboard || MAIN_KEYBOARD
    };

    const res = await fetch(`${TELEGRAM_API}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    const data = await res.json();
    if (!data.ok) {
      console.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ:", data);
    }
  } catch (err) {
    console.error("‚ùå –û—à–∏–±–∫–∞ fetch:", err.message);
  }
}

// üìå –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
async function checkUpdates() {
  const res = await pool.query("SELECT * FROM sites");
  for (const row of res.rows) {
    const { chat_id, url, selector, last_hash } = row;

    try {
      const domain = new URL(url).hostname.replace("www.", "");

      if (RSS_MIRRORS[domain]) {
        const rssUrl = RSS_MIRRORS[domain](url);
        const feed = await rssParser.parseURL(rssUrl);

        if (feed.items && feed.items.length > 0) {
          const latestItem = feed.items[0];
          const contentToHash = latestItem.link || latestItem.title;
          const hash = crypto.createHash("md5").update(contentToHash).digest("hex");

          if (hash !== last_hash) {
            await pool.query(
              "UPDATE sites SET last_hash=$1, last_update=NOW() WHERE chat_id=$2 AND url=$3",
              [hash, chat_id, url]
            );

            await sendTelegramMessage(
              chat_id,
              `üîî –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞ <b>${url}</b>\n\n${latestItem.title}\n<code>${latestItem.link}</code>`
            );
          }
        }
      } else {
        const html = await safeFetch(url);
        const $ = cheerio.load(html);

        let elements = selector ? $(selector) : $(PRESET_SELECTORS[domain] || "body");
        const content = elements.text().trim().slice(0, 500);
        const hash = crypto.createHash("md5").update(content).digest("hex");

        if (hash !== last_hash) {
          await pool.query(
            "UPDATE sites SET last_hash=$1, last_update=NOW() WHERE chat_id=$2 AND url=$3",
            [hash, chat_id, url]
          );

          await sendTelegramMessage(
            chat_id,
            `üîî –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞ <b>${url}</b>`
          );
        }
      }
    } catch (err) {
      console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ ${url}:`, err.message);
    }
  }
}

// üïí –ê–≤—Ç–æ–ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç—ã
setInterval(checkUpdates, 150000);

// üìå –†—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
async function manualCheckUpdates(chatId) {
  const res = await pool.query("SELECT * FROM sites WHERE chat_id=$1", [chatId]);
  for (const row of res.rows) {
    try {
      const domain = new URL(row.url).hostname.replace("www.", "");
      let updated = false;

      if (RSS_MIRRORS[domain]) {
        const rssUrl = RSS_MIRRORS[domain](row.url);
        const feed = await rssParser.parseURL(rssUrl);
        if (feed.items && feed.items.length > 0) {
          await sendTelegramMessage(chatId, `üîî –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø–æ—Å—Ç —Å <b>${row.url}</b>:\n${feed.items[0].title}\n<code>${feed.items[0].link}</code>`);
          updated = true;
        }
      }

      if (!updated) {
        await sendTelegramMessage(chatId, `‚ÑπÔ∏è –î–∞–Ω–Ω—ã—Ö –ø–æ <b>${row.url}</b> –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.`);
      }
    } catch (err) {
      await sendTelegramMessage(chatId, `‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ <b>${row.url}</b>: ${err.message}`);
    }
  }
}

// üì© –í–µ–±—Ö—É–∫ Telegram
app.post(`/webhook/${TELEGRAM_TOKEN}`, async (req, res) => {
  console.log("üì© Update:", JSON.stringify(req.body, null, 2));

  if (req.body.message && req.body.message.text) {
    const message = req.body.message;
    const chatId = message.chat.id;
    const text = message.text.trim();

    if (text === "/start") {
      await sendTelegramMessage(chatId, "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π.\n–ö–Ω–æ–ø–∫–∏ —Å–Ω–∏–∑—É –ø–æ–º–æ–≥—É—Ç —É–ø—Ä–∞–≤–ª—è—Ç—å –º–Ω–æ–π!");
    }

    else if (text === "üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è") {
      await sendTelegramMessage(chatId, "‚è≥ –ü—Ä–æ–≤–µ—Ä—è—é —Å–∞–π—Ç—ã...");
      await manualCheckUpdates(chatId);
      await sendTelegramMessage(chatId, "‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!");
    }

    else if (text === "‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–∞–π—Ç") {
      await sendTelegramMessage(chatId, "–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n<code>/monitor &lt;url&gt; [selector=...]</code>");
    }

    else if (text === "üìã –ú–æ–∏ —Å–∞–π—Ç—ã") {
      const result = await pool.query("SELECT url FROM sites WHERE chat_id=$1", [chatId]);
      if (result.rows.length === 0) {
        await sendTelegramMessage(chatId, "üì≠ –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–∞–π—Ç–æ–≤.");
      } else {
        const list = result.rows.map(r => `‚Ä¢ <code>${r.url}</code>`).join("\n");
        await sendTelegramMessage(chatId, `üìã –í–∞—à–∏ —Å–∞–π—Ç—ã:\n${list}`);
      }
    }

    else if (text === "‚ùå –£–¥–∞–ª–∏—Ç—å —Å–∞–π—Ç") {
      await sendTelegramMessage(chatId, "–£–¥–∞–ª–µ–Ω–∏–µ –ø–æ–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ –∫–æ–º–∞–Ω–¥—É:\n<code>/delete &lt;url&gt;</code>");
    }

    else if (text === "‚ÑπÔ∏è –ü–æ–º–æ—â—å") {
      await sendTelegramMessage(chatId,
        "‚ÑπÔ∏è –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:\n\n" +
        "‚Ä¢ <b>/start</b> ‚Äî –æ—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é\n" +
        "‚Ä¢ <b>/monitor &lt;url&gt; [selector=...]</b> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å —Å–∞–π—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞\n" +
        "‚Ä¢ üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è ‚Äî —Ä—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∞–π—Ç–æ–≤\n" +
        "‚Ä¢ üìã –ú–æ–∏ —Å–∞–π—Ç—ã ‚Äî —Å–ø–∏—Å–æ–∫ –≤–∞—à–∏—Ö —Å–∞–π—Ç–æ–≤\n" +
        "‚Ä¢ ‚ùå –£–¥–∞–ª–∏—Ç—å —Å–∞–π—Ç ‚Äî —É–¥–∞–ª–∏—Ç—å —Å–∞–π—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ (–∏–ª–∏ —á–µ—Ä–µ–∑ <b>/delete &lt;url&gt;</b>)\n" +
        "‚Ä¢ ‚ÑπÔ∏è –ü–æ–º–æ—â—å ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ"
      );
    }

    else if (text.startsWith("/monitor ")) {
      const args = text.split(" ");
      const url = args[1];
      const selectorArg = args.find(a => a.startsWith("selector="));
      let selector = selectorArg ? selectorArg.replace("selector=", "") : null;

      if (!url) {
        await sendTelegramMessage(chatId, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\n<code>/monitor &lt;url&gt; [selector=...]</code>");
      } else {
        try {
          const domain = new URL(url).hostname.replace("www.", "");
          if (!selector) {
            selector = PRESET_SELECTORS[domain] || null;
          }

          await pool.query(
            "INSERT INTO sites (chat_id, url, selector, last_hash, last_update) VALUES ($1,$2,$3,'',NOW()) ON CONFLICT DO NOTHING",
            [chatId, url, selector]
          );

          await sendTelegramMessage(
            chatId,
            `‚úÖ –ë—É–¥—É —Å–ª–µ–¥–∏—Ç—å –∑–∞: <b>${url}</b>${selector ? ` (—Å–µ–ª–µ–∫—Ç–æ—Ä: <code>${selector}</code>)` : ""}`
          );
        } catch (e) {
          await sendTelegramMessage(chatId, "‚ùå –û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL");
        }
      }
    }
  }

  res.sendStatus(200);
});

// üöÄ –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`‚úÖ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
});
