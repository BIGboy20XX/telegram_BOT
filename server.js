import express from "express";
import fetch from "node-fetch";
import * as cheerio from "cheerio"; // ‚úÖ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–º–ø–æ—Ä—Ç cheerio
import crypto from "crypto";
import { Pool } from "pg";
import Parser from "rss-parser";

const app = express();
app.use(express.json({ limit: "2mb" }));

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

const TELEGRAM_TOKEN = process.env.TELEGRAM_TOKEN;
if (!TELEGRAM_TOKEN) {
  console.error("‚ùå –û—à–∏–±–∫–∞: TELEGRAM_TOKEN –Ω–µ –∑–∞–¥–∞–Ω!");
  process.exit(1);
}
const TELEGRAM_API = `https://api.telegram.org/bot${TELEGRAM_TOKEN}`;
const rssParser = new Parser();

// –ü—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
const PRESET_SELECTORS = {
  "reddit.com": ".Post",
  "tumblr.com": ".post"
};

// üîó –ó–µ—Ä–∫–∞–ª–∞ –¥–ª—è –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö —Å–∞–π—Ç–æ–≤
const RSS_MIRRORS = {
  "twitter.com": url => {
    const username = url.split("/").filter(Boolean).pop();
    return [
      `https://nitter.net/${username}/rss`,
      `https://nitter.lacontrevoie.fr/${username}/rss`,
      `https://nitter.poast.org/${username}/rss`,
      `https://nitter.fdn.fr/${username}/rss`
    ];
  },
  "x.com": url => {
    const username = url.split("/").filter(Boolean).pop();
    return [
      `https://nitter.net/${username}/rss`,
      `https://nitter.lacontrevoie.fr/${username}/rss`,
      `https://nitter.poast.org/${username}/rss`,
      `https://nitter.fdn.fr/${username}/rss`
    ];
  },
  "instagram.com": url => {
    const username = url.split("/").filter(Boolean).pop();
    return [
      `https://rsshub.app/instagram/user/${username}`,
      `https://ig-rss.com/rss/${username}`,
      `https://insta-rss.vercel.app/${username}`
    ];
  },
  "reddit.com": url => {
    return [url.endsWith("/") ? `${url}.rss` : `${url}/.rss`];
  },
 "tumblr.com": url => {
  try {
    const u = new URL(url);
    let blogName = null;

    if (u.hostname.endsWith(".tumblr.com")) {
      blogName = u.hostname.split(".")[0];
    } else if (u.hostname === "www.tumblr.com") {
      // –ü—Ä–∏–º–µ—Ä—ã:
      // https://www.tumblr.com/blog/unseenwarriorsellsword
      // https://www.tumblr.com/unseenwarriorsellsword
      const parts = u.pathname.split("/").filter(Boolean);
      blogName = parts.includes("blog") ? parts[parts.indexOf("blog") + 1] : parts[0];
    }


      if (!blogName || blogName === "www" || blogName === "undefined") {
      console.error("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å Tumblr-–±–ª–æ–≥ –¥–ª—è URL:", url);
      return [];
    }

      return [
      `https://${blogName}.tumblr.com/rss`,
      `https://rsshub.app/tumblr/blog/${blogName}`
    ];
  } catch (err) {
    console.error("‚ö†Ô∏è –û—à–∏–±–∫–∞ Tumblr-–ø–∞—Ä—Å–µ—Ä–∞:", err.message);
    return [];
  }
},
};


// üì© –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
async function sendTelegramMessage(chatId, text, keyboard = null) {
  try {
    const body = {
      chat_id: chatId,
      text,
      parse_mode: "HTML"
    };
    if (keyboard) {
      body.reply_markup = keyboard;
    }
    const res = await fetch(`${TELEGRAM_API}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    const data = await res.json();
    if (!data.ok) {
      console.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ:", data);
    }
  } catch (err) {
    console.error("‚ùå –û—à–∏–±–∫–∞ fetch:", err.message);
  }
}


// üìå –†–∞–Ω–¥–æ–º–Ω—ã–π User-Agent
function getRandomUserAgent() {
  const agents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.3 Safari/605.1.15",
    "Mozilla/5.0 (X11; Linux x86_64) Gecko/20100101 Firefox/125.0",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile Safari/604.1",
    "Mozilla/5.0 (iPad; CPU OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile Safari/604.1"
  ];
  return agents[Math.floor(Math.random() * agents.length)];
}

// üìå –ó–∞–¥–µ—Ä–∂–∫–∞
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// üìå –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π (—á–µ—Ä–µ–∑ RSS –∏–ª–∏ fallback)
async function checkUpdates() {
  const res = await pool.query("SELECT * FROM sites WHERE chat_id != 0");
  for (const row of res.rows) {
    const { chat_id, url, selector, last_hash } = row;

    try {
      const domain = new URL(url).hostname.replace("www.", "");
      let feed = null;
let mirrors = [];
if (domain.includes("tumblr.com")) {
  mirrors = RSS_MIRRORS["tumblr.com"](url);
} else if (RSS_MIRRORS[domain]) {
  mirrors = RSS_MIRRORS[domain](url);
}

      // üì∞ –ü—Ä–æ–±—É–µ–º RSS –∑–µ—Ä–∫–∞–ª–∞
      if (RSS_MIRRORS[domain]) {
        const mirrors = RSS_MIRRORS[domain](url);
        for (const mirror of mirrors) {
          try {
            feed = await rssParser.parseURL(mirror);
            console.log(`‚úÖ RSS –∑–µ—Ä–∫–∞–ª–æ —Å—Ä–∞–±–æ—Ç–∞–ª–æ: ${mirror}`);
            break;
          } catch (err) {
            console.error(`‚ö†Ô∏è –ó–µ—Ä–∫–∞–ª–æ ${mirror} –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–æ: ${err.message}`);
            // –µ—Å–ª–∏ 429 –∏–ª–∏ 503 ‚Üí –ø—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–µ–µ –∑–µ—Ä–∫–∞–ª–æ
            if (err.message.includes("429") || err.message.includes("503")) {
              continue;
            }
          }
        }
      }

      // üì∞ –ï—Å–ª–∏ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å RSS
      if (feed && feed.items && feed.items.length > 0) {
        const latestItem = feed.items[0];
        const contentToHash = (latestItem.link || "") + (latestItem.title || "");
        const hash = crypto.createHash("md5").update(contentToHash).digest("hex");

        if (hash !== last_hash) {
          await pool.query(
            "UPDATE sites SET last_hash=$1, last_update=NOW() WHERE chat_id=$2 AND url=$3",
            [hash, chat_id, url]
          );
          await sendTelegramMessage(
            chat_id,
            `üîî –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞ <b>${url}</b>\n\n${latestItem.title}\n<code>${latestItem.link}</code>`
          );
        }
        await sleep(1000 + Math.random() * 1500);
        continue;
      }

      // üåê Fallback: HTML-–ø–∞—Ä—Å–∏–Ω–≥
      const response = await fetch(url, {
        headers: {
          "User-Agent": getRandomUserAgent(),
          "Accept-Language": "en-US,en;q=0.9"
        }
      });

      if (!response.ok) throw new Error(`HTTP ${response.status}`);

      const html = await response.text();
      const $ = cheerio.load(html);

      let elements = selector ? $(selector) : $(PRESET_SELECTORS[domain] || "body");

      const content = (
        elements.text().trim() +
        elements.find("a").map((i, el) => $(el).attr("href")).get().join(" ")
      ).slice(0, 5000);

      console.log(`üëÄ –ü—Ä–æ–≤–µ—Ä–∫–∞ ${url}`);
      console.log("‚û°Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ–ª–µ–∫—Ç–æ—Ä:", selector || PRESET_SELECTORS[domain] || "body");
      console.log("üìÑ –ò–∑–≤–ª–µ—á—ë–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç:", content.slice(0, 300) + "...");

      const hash = crypto.createHash("md5").update(content).digest("hex");

      if (hash !== last_hash) {
        await pool.query(
          "UPDATE sites SET last_hash=$1, last_update=NOW() WHERE chat_id=$2 AND url=$3",
          [hash, chat_id, url]
        );
        await sendTelegramMessage(chat_id, `üîî –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞ <b>${url}</b>`);
      }
    } catch (err) {
      console.error(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ ${url}:`, err.message);
      await sendTelegramMessage(chat_id, `‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ <b>${url}</b>: ${err.message}`);
    }

    await sleep(1000 + Math.random() * 2000);
  }
}


// üìå –†—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (—Ç–µ–ø–µ—Ä—å –∫–∞–∫ checkUpdates)
async function manualCheckUpdates(chatId) {
  const res = await pool.query("SELECT * FROM sites WHERE chat_id=$1", [chatId]);
  for (const row of res.rows) {
    const { url, selector, last_hash } = row;

    try {
      const domain = new URL(url).hostname.replace("www.", "");
      let feed = null;

      if (RSS_MIRRORS[domain]) {
        const mirrors = RSS_MIRRORS[domain](url);
        for (const mirror of mirrors) {
          try {
            feed = await rssParser.parseURL(mirror);
            console.log(`‚úÖ –†—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –∑–µ—Ä–∫–∞–ª–æ —Å—Ä–∞–±–æ—Ç–∞–ª–æ ${mirror}`);
            break;
          } catch (err) {
            console.error(`‚ö†Ô∏è –†—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞: –∑–µ—Ä–∫–∞–ª–æ ${mirror} –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–æ: ${err.message}`);
            if (err.message.includes("429") || err.message.includes("503")) {
              continue;
            }
          }
        }
      }

      if (feed && feed.items && feed.items.length > 0) {
        await sendTelegramMessage(
          chatId,
          `üîî –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø–æ—Å—Ç —Å <b>${url}</b>:\n${feed.items[0].title}\n<code>${feed.items[0].link}</code>`
        );
        await sleep(1000 + Math.random() * 1500);
        continue;
      }

      // üåê Fallback
      const response = await fetch(url, {
        headers: {
          "User-Agent": getRandomUserAgent(),
          "Accept-Language": "en-US,en;q=0.9"
        }
      });

      if (!response.ok) throw new Error(`HTTP ${response.status}`);

      const html = await response.text();
      const $ = cheerio.load(html);

      let elements = selector ? $(selector) : $(PRESET_SELECTORS[domain] || "body");

      const content = (
        elements.text().trim() +
        elements.find("a").map((i, el) => $(el).attr("href")).get().join(" ")
      ).slice(0, 5000);

      const hash = crypto.createHash("md5").update(content).digest("hex");

      if (hash !== last_hash) {
        await pool.query(
          "UPDATE sites SET last_hash=$1, last_update=NOW() WHERE chat_id=$2 AND url=$3",
          [hash, chatId, url]
        );
        await sendTelegramMessage(chatId, `üîî –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–∞ <b>${url}</b>`);
      } else {
        await sendTelegramMessage(chatId, `‚ÑπÔ∏è –ù–æ–≤—ã—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –Ω–∞ <b>${url}</b> –Ω–µ—Ç.`);
      }
    } catch (err) {
      await sendTelegramMessage(chatId, `‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ <b>${url}</b>: ${err.message}`);
    }

    await sleep(1000 + Math.random() * 2000);
  }
}



// üïí –ê–≤—Ç–æ–ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç
setInterval(checkUpdates, 900000);

// üì© –í–µ–±—Ö—É–∫ Telegram
const waitingForURL = {};

app.post(`/webhook/${TELEGRAM_TOKEN}`, async (req, res) => {
  if (req.body.message && req.body.message.text) {
    const message = req.body.message;
    const chatId = message.chat.id;
    const text = message.text.trim();

    const mainKeyboard = {
      keyboard: [
        ["‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–∞–π—Ç", "üìã –ú–æ–∏ —Å–∞–π—Ç—ã"],
        ["‚ùå –£–¥–∞–ª–∏—Ç—å —Å–∞–π—Ç", "üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"],
        ["‚ÑπÔ∏è –ü–æ–º–æ—â—å"]
      ],
      resize_keyboard: true
    };

    if (waitingForURL[chatId]) {
      try {
        const url = text;
        let selector = PRESET_SELECTORS[new URL(url).hostname.replace("www.", "")] || null;
        await pool.query(
          "INSERT INTO sites (chat_id, url, selector, last_hash, last_update) VALUES ($1,$2,$3,'',NOW()) ON CONFLICT DO NOTHING",
          [chatId, url, selector]
        );
        await sendTelegramMessage(chatId, `‚úÖ –ë—É–¥—É —Å–ª–µ–¥–∏—Ç—å –∑–∞: <b>${url}</b>`, mainKeyboard);
      } catch {
        await sendTelegramMessage(chatId, "‚ùå –û—à–∏–±–∫–∞: –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL", mainKeyboard);
      }
      delete waitingForURL[chatId];
      return res.sendStatus(200);
    }

    if (text === "/start") {
      await sendTelegramMessage(chatId, "üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π.\n–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:", mainKeyboard);
    } else if (text === "üìã –ú–æ–∏ —Å–∞–π—Ç—ã") {
      const result = await pool.query("SELECT url FROM sites WHERE chat_id=$1", [chatId]);
      if (result.rows.length === 0) {
        await sendTelegramMessage(chatId, "üì≠ –£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–∞–π—Ç–æ–≤.", mainKeyboard);
      } else {
        const list = result.rows.map((r, i) => `${i + 1}. <code>${r.url}</code>`).join("\n");
        await sendTelegramMessage(chatId, `üìã –í–∞—à–∏ —Å–∞–π—Ç—ã:\n${list}\n\n–î–ª—è —É–¥–∞–ª–µ–Ω–∏—è –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Å–∞–π—Ç–∞ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞ ¬´‚ùå –£–¥–∞–ª–∏—Ç—å —Å–∞–π—Ç¬ª.`, mainKeyboard);
      }
    } else if (text === "‚ùå –£–¥–∞–ª–∏—Ç—å —Å–∞–π—Ç") {
      await sendTelegramMessage(chatId, "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Å–∞–π—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å.", mainKeyboard);
    } else if (/^\d+$/.test(text)) {
      const index = parseInt(text);
      const result = await pool.query("SELECT url FROM sites WHERE chat_id=$1", [chatId]);
      if (index > 0 && index <= result.rows.length) {
        const urlToDelete = result.rows[index - 1].url;
        await pool.query("DELETE FROM sites WHERE chat_id=$1 AND url=$2", [chatId, urlToDelete]);
        await sendTelegramMessage(chatId, `‚ùå –°–∞–π—Ç <code>${urlToDelete}</code> —É–¥–∞–ª—ë–Ω.`, mainKeyboard);
      } else {
        await sendTelegramMessage(chatId, "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —Å–∞–π—Ç–∞.", mainKeyboard);
      }
    } else if (text === "üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è") {
      await sendTelegramMessage(chatId, "‚è≥ –ü—Ä–æ–≤–µ—Ä—è—é —Å–∞–π—Ç—ã...", mainKeyboard);
      await manualCheckUpdates(chatId);
      await sendTelegramMessage(chatId, "‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!", mainKeyboard);
    } else if (text === "‚ÑπÔ∏è –ü–æ–º–æ—â—å") {
      await sendTelegramMessage(chatId,
        "‚ÑπÔ∏è –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:\n\n" +
        "‚Ä¢ <b>/start</b> ‚Äî –æ—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é\n" +
        "‚Ä¢ <b>‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–∞–π—Ç</b> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å —Å–∞–π—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞\n" +
        "‚Ä¢ <b>üìã –ú–æ–∏ —Å–∞–π—Ç—ã</b> ‚Äî —Å–ø–∏—Å–æ–∫ –≤–∞—à–∏—Ö —Å–∞–π—Ç–æ–≤\n" +
        "‚Ä¢ <b>‚ùå –£–¥–∞–ª–∏—Ç—å —Å–∞–π—Ç</b> ‚Äî —É–¥–∞–ª–∏—Ç—å —Å–∞–π—Ç –ø–æ –Ω–æ–º–µ—Ä—É\n" +
        "‚Ä¢ <b>üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è</b> ‚Äî —Ä—É—á–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∞–π—Ç–æ–≤\n" +
        "‚Ä¢ <b>‚ÑπÔ∏è –ü–æ–º–æ—â—å</b> ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ", mainKeyboard);
    } else if (text === "‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–∞–π—Ç") {
      waitingForURL[chatId] = true;
      await sendTelegramMessage(chatId, "–í–≤–µ–¥–∏—Ç–µ URL —Å–∞–π—Ç–∞ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞:", mainKeyboard);
    }
  }
  res.sendStatus(200);
});

// üöÄ –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
const PORT = process.env.PORT || 3000;
app.listen(PORT, async () => {
  console.log(`‚úÖ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);

  try {
    await pool.query(
      "INSERT INTO sites (chat_id, url, selector, last_hash, last_update) VALUES ($1,$2,$3,'',NOW()) ON CONFLICT DO NOTHING",
      [0, "https://example.com", "body"]
    );
    console.log("üîß –¢–µ—Å—Ç–æ–≤—ã–π —Å–∞–π—Ç https://example.com –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–∞–∑—É (chat_id=0).");
  } catch (err) {
    console.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å–∞–π—Ç–∞:", err.message);
  }

  console.log("‚è≥ –í—ã–ø–æ–ª–Ω—è—é —Ç–µ—Å—Ç–æ–≤—É—é –ø—Ä–æ–≤–µ—Ä–∫—É...");
  await checkUpdates();
  console.log("‚úÖ –¢–µ—Å—Ç–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!");
});
